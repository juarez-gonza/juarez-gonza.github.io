#+options: ^:nil
#+title: Empathising with C++20 coroutines

* What is this about?


A couple of years ago I wrote some slides for a course on the
underlying principles and decisions behind C++20 coroutines (or at
least my intepretation of these). This happened around the same time I
was finishing my undergrad, so it got mixed with life and never saw
light. Now that I have some time I will try to put these ideas
somewhere.


C++20 coroutines is one of those things in C++ that gets (not) praised
by its seemingly complex design and the understanding it requires from
its users. Luckily nowadays its users do not have to implement the
difficult part (the =promise_type=) because a library may have already
done it (for most users, that library may be [[https://www.boost.org/doc/libs/1_89_0/doc/html/boost_asio.html][asio]]).


Still, in this post I want to *empathise* with the design of C++20
coroutines. This post is an attempt to convince myself of why each
part of the design of coroutines API is *needed*, and maybe think about
how it could have been changed or simplified while retaining its
expressive power.

* Divulging C++20 coroutines introductions


I have not read posts or seen many talks about C++20 coroutines since
I first thought about this post, so the contents of this paragraph may
no longer apply.  My impression at the time was that many
introductions to the topic did not work as good as they could because
of two common pitfalls:


1. *Content overloading*: Many seemed to try to explain asynchoronous
   programming and the C++20 coroutine mechanism in parallel (pun
   intended). Both topics are complex by themselves, explaining them
   without a clear distinction seems like a bad idea.
2. *Focus on implementation details*:
   + "Activation/Coroutine frame",
   + "heap",
   + "heap ellision",
   + "A coroutine is a state machine that...".
   You could define a coroutine in those terms. Is that level of
   abstraction useful at an introduction level? I think not.


The former issue is solvable: /advertise/ to the reader that basic
knowledge about continuations and asynchronous programming is
required, provide sources if adequate. This we do now. Here are some
resources, most of them are LISP (Scheme/Racket) based:


+ [[https://docs.racket-lang.org/reference/eval-model.html?q=continuation#(part._cont-model)][Sub-expression evaluation and Continuations]] and [[https://docs.racket-lang.org/reference/eval-model.html?q=continuation#(part._.Tail_.Position)][Tail Position]]
  sections of the Racket evaluation model does a very good, succint
  job at the core idea of a continuation.
+ [[https://dl.acm.org/doi/abs/10.1145/800055.802046][Continuations and coroutines]] shows how coroutines can be implemented
  via first class continuations (=call/cc=). No need to follow every
  detail, but just to see how continuations are really behind all of
  this. It is then easier to recognise callbacks and coroutines as
  forms of continuations and go back and forth between them, according
  to whatever suits best to your way of thinking.
+ [[https://dl.acm.org/doi/10.1145/1462166.1462167][Revisiting coroutines]] explains the most prevalent classifications of
  coroutines (stackless/stackful, symmetric/asymmetric). Just so that
  you know what people means when they say C++20 coroutines are
  stackless and asymmetric.


Consider yourself advertised, I wont go that much into what a
continuation is [fn:1].


The second pitfall is tough to avoid. The approach adopted in this
post is that of postponing the discussion of implementation details
exposed by the C++20 coroutines API until needed, accompanied by
adequate motivation.

* Some misunderstandings about C++20 coroutines


There are some common misunderstandings about what C++20 coroutines
are. It is important to deal with these right away. Otherwise the
reader may be frustrated when failing to fill-in the gaps between the
notion of C++20 coroutines and whatever sort of mechanism the reader
is already acquainted with.

+ *"Hey! These coroutines are nothing like those in Lua, Go, nor
  Javascript!"*: That is right. C++20 coroutines follow their own
  approach, with some similar aspects to other languages' coroutines,
  but many differences[fn:2].
+ *"Are =std::promise= and coroutine's =promise_type= related?"*: No, this
  is yet another C++ misnomer.
+ *"When do threads come into play?"*: Think about callbacks, do
  callbacks have any concurrency/threading by themselves? No! However
  /task queues/ of callbacks can be constructed. These task queues may
  be concurrently accessed by many threads. Something analogous
  happens with coroutines: their nature does not involve concurrency,
  but they compose rather nicely with concurrent solutions. This post
  deals with the guts of C++20 coroutines, so we will be ignoring the
  concurrent aspect throughout the rest of the post.

** TODO From coroutines to callbacks and the other way around

* TODO Empathising with c++20 coroutines

loootttss of subsections

* TODO Conclusions

# * i may have something to write about in the future...

# ** latex math

# \begin{equation}                        % arbitrary environments,
# x=\sqrt{b}                              % even tables, figures, etc
# \end{equation}

# if $a^2=b$ and \( b=2 \), then the solution must be
# either $$ a=+\sqrt{2} $$ or \[ a=-\sqrt{2}. \]

# ** including code from a file

# #+include: ./main.cpp src c++ :lines "3-6"

* Footnotes

[fn:1] I would like to make a post explaining continuations and how these
can be recognised, but we will see how that goes.

[fn:2] What's more, coroutines of Go, Javascript, and Lua are not even
identical to each other. The article [[https://dl.acm.org/doi/10.1145/1462166.1462167][Revisiting Coroutines]] may be of
interest.

