#+options: ^:nil
#+title: Empathising with C++20 coroutines

* What is this about?


A couple of years ago I wrote some slides for a course on the
underlying principles and decisions behind C++20 coroutines (or at
least my intepretation of these). This happened around the same time I
was finishing my undergrad, so it got mixed with life and never saw
light. Now that I have some time I will try to put these ideas
somewhere.


C++20 coroutines is one of those things in C++ that gets (not) praised
by its seemingly complex design and the understanding it requires from
its users. Luckily nowadays its users do not have to implement the
difficult part (the =promise_type=) because a library may have already
done it (for most users, that library may be [[https://www.boost.org/doc/libs/1_89_0/doc/html/boost_asio.html][asio]]).


Still, in this post I want to *empathise* with the design of C++20
coroutines. This post is an attempt to convince myself of why each
part of the design of coroutines API is *needed*, and maybe think about
how it could have been changed or simplified while retaining its
expressive power.

* Divulging C++20 coroutines introductions


I have not read posts or seen many talks about C++20 coroutines since
I first thought about this post, so the contents of this paragraph may
no longer apply.  My impression at the time was that many
introductions to the topic did not work as good as they could because
of two common pitfalls:


1. *Content overloading*: Many seemed to try to explain asynchoronous
   programming and the C++20 coroutine mechanism in parallel (pun
   intended). Both topics are complex by themselves, explaining them
   without a clear distinction seems like a bad idea.
2. *Focus on implementation details*:
   + "Activation/Coroutine frame",
   + "heap",
   + "heap ellision",
   + "A coroutine is a state machine that...".
   You could define a coroutine in those terms. Is that level of
   abstraction useful at an introduction level? I think not.


The former issue is solvable: /advertise/ to the reader that basic
knowledge about continuations and asynchronous programming is
required, provide sources if adequate. This we do now. Here are some
resources, most of them are LISP (Scheme/Racket) based:


+ [[https://docs.racket-lang.org/reference/eval-model.html?q=continuation#(part._cont-model)][Sub-expression evaluation and Continuations]] and [[https://docs.racket-lang.org/reference/eval-model.html?q=continuation#(part._.Tail_.Position)][Tail Position]]
  sections of the Racket evaluation model does a very good, succint
  job at the core idea of a continuation.
+ [[https://dl.acm.org/doi/abs/10.1145/800055.802046][Continuations and coroutines]] shows how coroutines can be implemented
  via first class continuations (=call/cc=). No need to follow every
  detail, but just to see how continuations are really behind all of
  this. It is then easier to recognise callbacks and coroutines as
  forms of continuations and go back and forth between them, according
  to whatever suits best to your way of thinking.
+ [[https://dl.acm.org/doi/10.1145/1462166.1462167][Revisiting coroutines]] explains the most prevalent classifications of
  coroutines (stackless/stackful, symmetric/asymmetric). Just so that
  you know what people means when they say C++20 coroutines are
  stackless and asymmetric.


Consider yourself advertised, I wont go that much into what a
continuation is [fn:1].


The second pitfall is tough to avoid. The approach adopted in this
post is that of postponing the discussion of implementation details
exposed by the C++20 coroutines API until needed, accompanied by
adequate motivation.

* Some misunderstandings about C++20 coroutines


There are some common misunderstandings about what C++20 coroutines
are. It is important to deal with these right away. Otherwise the
reader may be frustrated when failing to fill-in the gaps between the
notion of C++20 coroutines and whatever sort of mechanism the reader
is already acquainted with.

+ *"Hey! These coroutines are nothing like those in Lua, Go, nor
  Javascript!"*: That is right. C++20 coroutines follow their own
  approach. Some aspects may be familiar to you from other languages,
  but in general you should expect many differences with C++20
  coroutines[fn:2].
+ *"Are =std::promise= and a coroutine's =promise_type= related?"*: No, this
  is yet another C++ misnomer.
+ *"When do threads come into play?"*: Do callbacks involve any
  concurrency/threading by themselves? No! However /task queues/ of
  callbacks can be constructed. These task queues may be concurrently
  accessed by many threads. Something analogous happens with
  coroutines: their nature does not involve concurrency, but they
  compose rather nicely with concurrent solutions. This post deals
  with the guts of C++20 coroutines, so we will be ignoring the
  concurrent aspect throughout most of this post.

** TODO From coroutines to callbacks and the other way around

It will be useful to roughly delineate how to convert code using C++20
coroutines to /continuation passing style/ (CPS, fancy terminology for
callbacks) and the other way around. CPS is consistent between
different programming languages and better understood by the general
public. The essentiality of some parts of the C++20 coroutines API is
sometimes easier to see when we inspect the "equivalent" CPS code.


Let us begin with the simple case of a coroutine without exceptions,
=co_await= calls in a loop, nor recursion in its body.


# #+include: ./main.cpp src c++ :lines "3-6"


Our initial translation to CPS is quite straight forward:


1. For each expression being awaited, write a function that takes a
   callback as parameter.
2. If the result of =co_await= expression is assigned to some local
   variable, turn this local variable into the sole parameter of a new
   function. Otherwise, create a function that does not take any
   parameter.  This function is used as the callback parameter of the
   function written in step 1.
3. Everything in the coroutine body after the statement containing the
   =co_await= expression is the body of the function created in step 2.


Under this procedure, the preceding code translates into CPS as
follows:


# #+include: ./main.cpp src c++ :lines "3-6"


Before considering the case of =co_await= calls in a loop or recursion
in the body of a coroutine, let us deal with exceptions.


# #+include: ./main.cpp src c++ :lines "3-6"


Whenever a =co_await= expression may throw, steps above are
modified as follows.


1. For each expression being awaited
   * If the =co_await= expression does not throw, then write a function
     that takes one callback as parameter.
   * Otherwise, write a function that takes two callbacks as
     parameters. The first one for the successful case, the second one
     for the error case.

2. If the result of a =co_await= expression is assigned to some local
   variable, turn this local variable into the sole parameter of a new
   function. Otherwise, create a function that does not take any
   parameter. This function is used as the (successful case) callback
   parameter of the function written in step 1.

   In addition, if the =co_await= expression may throw, then create
   another function that takes as sole parameter an instance of a type
   representing the exception captured in the =catch= block. This latter
   function is used as the error case callback parameter of the
   function written in step 1.

3. Everything (within the =try= block and after the =try / catch=
   construct until the end of the coroutine body) of a (throwing)
   =co_await= expression is the body of the function (for the successful
   case) created in step 2. If the =co_await= expression throws,
   everything withing the =catch= block and after the =try / catch=
   construct untis the end of the coroutine body is the body of the
   function for the error case created in step 2.


Under this procedure, the preceding code translates into CPS as
follows:


# #+include: ./main.cpp src c++ :lines "3-6"


Finally, let us consider iteration and recursion with
=co_await=. Consider the listing below.


# #+include: ./main.cpp src c++ :lines "3-6"


The core idea to translate this code to CPS is the same: put
everything after =co_await= in a callback. But this time the number of
callbacks needed (one per =co_await= execution) is not in correspondence
with the number of =co_await= expressions written in the code.

* TODO Empathising with c++20 coroutines

loootttss of subsections

* TODO Conclusions

# * i may have something to write about in the future...

# ** latex math

# \begin{equation}                        % arbitrary environments,
# x=\sqrt{b}                              % even tables, figures, etc
# \end{equation}

# if $a^2=b$ and \( b=2 \), then the solution must be
# either $$ a=+\sqrt{2} $$ or \[ a=-\sqrt{2}. \]

# ** including code from a file

# #+include: ./main.cpp src c++ :lines "3-6"

* Footnotes

[fn:1] I would like to make a post explaining continuations and how these
can be recognised, but we will see how that goes.

[fn:2] What's more, coroutines of Go, Javascript, and Lua are not even
identical to each other. The article [[https://dl.acm.org/doi/10.1145/1462166.1462167][Revisiting Coroutines]] may be of
interest.

