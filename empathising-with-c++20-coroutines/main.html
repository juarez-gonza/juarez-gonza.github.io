<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Empathising with C++20 coroutines</title>
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Empathising with C++20 coroutines</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org2b29ccc">What is this about?</a></li>
<li><a href="#org88b4d4d">Divulging C++20 coroutines introductions</a></li>
<li><a href="#org429aa88">Some misunderstandings about C++20 coroutines</a>
<ul>
<li><a href="#org24598a4"><span class="todo TODO">TODO</span> From coroutines to callbacks and the other way around</a></li>
</ul>
</li>
<li><a href="#org9a81d01"><span class="todo TODO">TODO</span> Empathising with c++20 coroutines</a></li>
<li><a href="#orgbb778fc"><span class="todo TODO">TODO</span> Conclusions</a></li>
</ul>
</div>
</div>

<div id="outline-container-org2b29ccc" class="outline-2">
<h2 id="org2b29ccc">What is this about?</h2>
<div class="outline-text-2" id="text-org2b29ccc">
<p>
A couple of years ago I wrote some slides for a course on the
underlying principles and decisions behind C++20 coroutines (or at
least my intepretation of these). This happened around the same time I
was finishing my undergrad, so it got mixed with life and never saw
light. Now that I have some time I will try to put these ideas
somewhere.
</p>


<p>
C++20 coroutines is one of those things in C++ that gets (not) praised
by its seemingly complex design and the understanding it requires from
its users. Luckily nowadays its users do not have to implement the
difficult part (the <code>promise_type</code>) because a library may have already
done it (for most users, that library may be <a href="https://www.boost.org/doc/libs/1_89_0/doc/html/boost_asio.html">asio</a>).
</p>


<p>
Still, in this post I want to <b>empathise</b> with the design of C++20
coroutines. This post is an attempt to convince myself of why each
part of the design of coroutines API is <b>needed</b>, and maybe think about
how it could have been changed or simplified while retaining its
expressive power.
</p>
</div>
</div>

<div id="outline-container-org88b4d4d" class="outline-2">
<h2 id="org88b4d4d">Divulging C++20 coroutines introductions</h2>
<div class="outline-text-2" id="text-org88b4d4d">
<p>
I have not read posts or seen many talks about C++20 coroutines since
I first thought about this post, so the contents of this paragraph may
no longer apply.  My impression at the time was that many
introductions to the topic did not work as good as they could because
of two common pitfalls:
</p>


<ol class="org-ol">
<li><b>Content overloading</b>: Many seemed to try to explain asynchoronous
programming and the C++20 coroutine mechanism in parallel (pun
intended). Both topics are complex by themselves, explaining them
without a clear distinction seems like a bad idea.</li>
<li><p>
<b>Focus on implementation details</b>:
</p>
<ul class="org-ul">
<li>"Activation/Coroutine frame",</li>
<li>"heap",</li>
<li>"heap ellision",</li>
<li>"A coroutine is a state machine that&#x2026;".</li>
</ul>
<p>
You could define a coroutine in those terms. Is that level of
abstraction useful at an introduction level? I think not.
</p></li>
</ol>


<p>
The former issue is solvable: <i>advertise</i> to the reader that basic
knowledge about continuations and asynchronous programming is
required, provide sources if adequate. This we do now. Here are some
resources, most of them are LISP (Scheme/Racket) based:
</p>


<ul class="org-ul">
<li><a href="https://docs.racket-lang.org/reference/eval-model.html?q=continuation#(part._cont-model)">Sub-expression evaluation and Continuations</a> and <a href="https://docs.racket-lang.org/reference/eval-model.html?q=continuation#(part._.Tail_.Position)">Tail Position</a>
sections of the Racket evaluation model does a very good, succint
job at the core idea of a continuation.</li>
<li><a href="https://dl.acm.org/doi/abs/10.1145/800055.802046">Continuations and coroutines</a> shows how coroutines can be implemented
via first class continuations (<code>call/cc</code>). No need to follow every
detail, but just to see how continuations are really behind all of
this. It is then easier to recognise callbacks and coroutines as
forms of continuations and go back and forth between them, according
to whatever suits best to your way of thinking.</li>
<li><a href="https://dl.acm.org/doi/10.1145/1462166.1462167">Revisiting coroutines</a> explains the most prevalent classifications of
coroutines (stackless/stackful, symmetric/asymmetric). Just so that
you know what people means when they say C++20 coroutines are
stackless and asymmetric.</li>
</ul>


<p>
Consider yourself advertised, I wont go that much into what a
continuation is <sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup>.
</p>


<p>
The second pitfall is tough to avoid. The approach adopted in this
post is that of postponing the discussion of implementation details
exposed by the C++20 coroutines API until needed, accompanied by
adequate motivation.
</p>
</div>
</div>

<div id="outline-container-org429aa88" class="outline-2">
<h2 id="org429aa88">Some misunderstandings about C++20 coroutines</h2>
<div class="outline-text-2" id="text-org429aa88">
<p>
There are some common misunderstandings about what C++20 coroutines
are. It is important to deal with these right away. Otherwise the
reader may be frustrated when failing to fill-in the gaps between the
notion of C++20 coroutines and whatever sort of mechanism the reader
is already acquainted with.
</p>

<ul class="org-ul">
<li><b>"Hey! These coroutines are nothing like those in Lua, Go, nor
Javascript!"</b>: That is right. C++20 coroutines follow their own
approach. Some aspects may be familiar to you from other languages,
but in general you should expect many differences with C++20
coroutines<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>.</li>
<li><b>"Are <code>std::promise</code> and a coroutine's <code>promise_type</code> related?"</b>: No, this
is yet another C++ misnomer.</li>
<li><b>"When do threads come into play?"</b>: Do callbacks involve any
concurrency/threading by themselves? No! However <i>task queues</i> of
callbacks can be constructed. These task queues may be concurrently
accessed by many threads. Something analogous happens with
coroutines: their nature does not involve concurrency, but they
compose rather nicely with concurrent solutions. This post deals
with the guts of C++20 coroutines, so we will be ignoring the
concurrent aspect throughout most of this post.</li>
</ul>
</div>

<div id="outline-container-org24598a4" class="outline-3">
<h3 id="org24598a4"><span class="todo TODO">TODO</span> From coroutines to callbacks and the other way around</h3>
<div class="outline-text-3" id="text-org24598a4">
<p>
It will be useful to roughly delineate how to convert code using C++20
coroutines to <i>continuation passing style</i> (CPS, fancy terminology for
callbacks) and the other way around. CPS is consistent between
different programming languages and better understood by the general
public. The essentiality of some parts of the C++20 coroutines API is
sometimes easier to see when we inspect the "equivalent" CPS code.
</p>


<p>
Let us begin with the simple case of a coroutine without exceptions,
<code>co_await</code> calls in a loop, nor recursion in its body.
</p>


<p>
Our initial translation to CPS is quite straight forward:
</p>


<ol class="org-ol">
<li>For each expression being awaited, write a function that takes a
callback as parameter.</li>
<li>If the result of <code>co_await</code> expression is assigned to some local
variable, turn this local variable into the sole parameter of a new
function. Otherwise, create a function that does not take any
parameter.  This function is used as the callback parameter of the
function written in step 1.</li>
<li>Everything in the coroutine body after the statement containing the
<code>co_await</code> expression is the body of the function created in step 2.</li>
</ol>


<p>
Under this procedure, the preceding code translates into CPS as
follows:
</p>


<p>
Before considering the case of <code>co_await</code> calls in a loop or recursion
in the body of a coroutine, let us deal with exceptions.
</p>


<p>
Whenever a <code>co_await</code> expression may throw, steps above are
modified as follows.
</p>


<ol class="org-ol">
<li>For each expression being awaited
<ul class="org-ul">
<li>If the <code>co_await</code> expression does not throw, then write a function
that takes one callback as parameter.</li>
<li>Otherwise, write a function that takes two callbacks as
parameters. The first one for the successful case, the second one
for the error case.</li>
</ul></li>

<li><p>
If the result of a <code>co_await</code> expression is assigned to some local
variable, turn this local variable into the sole parameter of a new
function. Otherwise, create a function that does not take any
parameter. This function is used as the (successful case) callback
parameter of the function written in step 1.
</p>

<p>
In addition, if the <code>co_await</code> expression may throw, then create
another function that takes as sole parameter an instance of a type
representing the exception captured in the <code>catch</code> block. This latter
function is used as the error case callback parameter of the
function written in step 1.
</p></li>

<li>Everything (within the <code>try</code> block and after the <code>try / catch</code>
construct until the end of the coroutine body) of a (throwing)
<code>co_await</code> expression is the body of the function (for the successful
case) created in step 2. If the <code>co_await</code> expression throws,
everything withing the <code>catch</code> block and after the <code>try / catch</code>
construct untis the end of the coroutine body is the body of the
function for the error case created in step 2.</li>
</ol>


<p>
Under this procedure, the preceding code translates into CPS as
follows:
</p>


<p>
Finally, let us consider iteration and recursion with
<code>co_await</code>. Consider the listing below.
</p>


<p>
The core idea to translate this code to CPS is the same: put
everything after <code>co_await</code> in a callback. But this time the number of
callbacks needed (one per <code>co_await</code> execution) is not in correspondence
with the number of <code>co_await</code> expressions written in the code.
</p>
</div>
</div>
</div>

<div id="outline-container-org9a81d01" class="outline-2">
<h2 id="org9a81d01"><span class="todo TODO">TODO</span> Empathising with c++20 coroutines</h2>
<div class="outline-text-2" id="text-org9a81d01">
<p>
loootttss of subsections
</p>
</div>
</div>

<div id="outline-container-orgbb778fc" class="outline-2">
<h2 id="orgbb778fc"><span class="todo TODO">TODO</span> Conclusions</h2>
<div class="outline-text-2" id="text-orgbb778fc">
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I would like to make a post explaining continuations and how these
can be recognised, but we will see how that goes.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
What's more, coroutines of Go, Javascript, and Lua are not even
identical to each other. The article <a href="https://dl.acm.org/doi/10.1145/1462166.1462167">Revisiting Coroutines</a> may be of
interest.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 29.3 (<a href="https://orgmode.org">Org</a> mode 9.6.15)</p>
</div>
</body>
</html>
